<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mood</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <div class="header">
        <h1 class="mood-header">Mood</h1>
        <p>Each composition is unique and evolves over time using generative principles.</p>
    </div>

    <div class="main-controls">
        <!-- Dice Randomizer -->
        <div class="dice-section">
            <button class="dice-button" id="dice-button">
                <span class="dice-icon">🎲</span>
                Randomize Everything
            </button>
        </div>

        <!-- Mood Section -->
        <div class="control-section" id="mood-section">
            <div class="section-header" onclick="toggleSection('mood')">
                <div class="section-title">
                    <div class="section-icon mood-icon">🎭</div>
                    <div>
                        <div class="section-info">Mood</div>
                        <div class="section-status" id="mood-status">Calm</div>
                    </div>
                </div>
                <button class="expand-btn" id="mood-expand">
                    <span>▼</span>
                </button>
            </div>
            <div class="section-content" id="mood-content">
                <div class="control-group">
                    <label class="control-label" for="mood">Musical Mood</label>
                    <select id="mood" onchange="updateMoodStatus()">
                        <option value="random">Random (Auto-changing)</option>
                        <option value="calm">Calm</option>
                        <option value="ethereal">Ethereal</option>
                        <option value="mysterious">Mysterious</option>
                        <option value="melancholic">Melancholic</option>
                        <option value="hopeful">Hopeful</option>
                        <option value="dreamy">Dreamy</option>
                        <option value="nostalgic">Nostalgic</option>
                        <option value="peaceful">Peaceful</option>
                        <option value="serene">Serene</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label" for="density">Note Density</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="density" min="1" max="10" value="5">
                        </div>
                        <div class="slider-labels">
                            <span>Sparse</span>
                            <span>Dense</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label" for="reverb">Reverb Amount</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="reverb" min="0" max="1" step="0.1" value="0.5">
                        </div>
                        <div class="slider-labels">
                            <span>Dry</span>
                            <span>Wet</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Melody Section -->
        <div class="control-section" id="melody-section">

            <div class="section-header" onclick="toggleSection('melody')">
                <div class="section-title">
                    <div class="toggle-btn" onclick="toggleMelody(event)">
                        <input type="checkbox" id="melody-toggle" onchange="updateMelodyStatus()" onclick="event.stopPropagation()">
                        <span class="toggle-indicator"></span>
                    </div>
                    <div class="section-icon melody-icon">🎹</div>
                    <div>
                        <div class="section-info">Melodic Instruments</div>
                        <div class="section-status" id="melody-status">Soft Piano</div>
                    </div>
                </div>
                <button class="expand-btn" id="melody-expand">
                    <span>▼</span>
                </button>
            </div>
            <div class="section-content" id="melody-content">
                <div class="control-group">
                    <label class="control-label" for="melodic-instrument">Instrument Type</label>
                    <select id="melodic-instrument" onchange="updateMelodyStatus()">
                        <option value="random">Random (Auto-changing)</option>
                        <option value="piano" selected>Soft Piano</option>
                        <option value="sampled-piano">Real Piano (Sampled)</option>
                        <option value="idm-electronic">IDM Electronic</option>
                        <option value="marimba">Marimba</option>
                        <option value="harp">Harp</option>
                        <option value="music-box">Music Box</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label" for="melodic-frequency">Note Frequency</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="melodic-frequency" min="1" max="10" value="4">
                        </div>
                        <div class="slider-labels">
                            <span>Rare</span>
                            <span>Often</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label" for="melodic-reverb">Melodic Reverb</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="melodic-reverb" min="0" max="1" step="0.05" value="0.8">
                        </div>
                        <div class="slider-labels">
                            <span>Dry</span>
                            <span>Wet</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Ocean Waves Section -->
        <div class="control-section" id="waves-section">
            <div class="section-header" onclick="toggleSection('waves')">
                <div class="section-title">
                    <div class="toggle-btn" onclick="toggleWaves(event)">
                        <input type="checkbox" id="noise-toggle" onchange="updateWavesStatus()" onclick="event.stopPropagation()">
                        <span class="toggle-indicator"></span>
                    </div>
                    <div class="section-icon waves-icon">🌊</div>
                    <div>
                        <div class="section-info">Ocean Waves</div>
                        <div class="section-status" id="waves-status">Off</div>
                    </div>
                </div>
                <button class="expand-btn" id="waves-expand">
                    <span>▼</span>
                </button>
            </div>

            <div class="section-content" id="waves-content">
                <!-- Single column controls -->
                <div class="control-group">
                    <label class="control-label" for="noise-volume">Wave Volume</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="noise-volume" min="-15" max="5" step="1" value="-6">
                        </div>
                        <div class="slider-labels">
                            <span>Quiet</span>
                            <span>Loud</span>
                        </div>
                    </div>
                </div>

                <!-- Two-column layout for detailed controls -->
                <div class="waves-grid">
                    <!-- Left column - Wave Characteristics -->
                    <div class="waves-column">
                        <h4 class="column-header">Wave Characteristics</h4>

                        <div class="control-group">
                            <label class="control-label" for="base-level">Base Level</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="base-level" min="0" max="0.3" step="0.01" value="0.05">
                                </div>
                                <div class="slider-labels">
                                    <span>Silent</span>
                                    <span>Audible</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="peak-level">Peak Level</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="peak-level" min="0.1" max="0.8" step="0.01" value="0.4">
                                </div>
                                <div class="slider-labels">
                                    <span>Gentle</span>
                                    <span>Powerful</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="build-speed">Build Speed</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="build-speed" min="0.5" max="5" step="0.1" value="2">
                                </div>
                                <div class="slider-labels">
                                    <span>Slow</span>
                                    <span>Fast</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="noise-type">Noise Type</label>
                            <select id="noise-type">
                                <option value="white">White (Bright)</option>
                                <option value="pink" selected>Pink (Natural)</option>
                                <option value="brown">Brown (Deep)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Right column - Timing & Filter -->
                    <div class="waves-column">
                        <h4 class="column-header">Timing & Filter</h4>

                        <div class="control-group">
                            <label class="control-label" for="min-duration">Min Duration (s)</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="min-duration" min="2" max="15" step="0.5" value="4">
                                </div>
                                <div class="slider-labels">
                                    <span>2s</span>
                                    <span>15s</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="max-duration">Max Duration (s)</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="max-duration" min="5" max="25" step="0.5" value="12">
                                </div>
                                <div class="slider-labels">
                                    <span>5s</span>
                                    <span>25s</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="pause-between">Pause Between (s)</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="pause-between" min="0.5" max="8" step="0.25" value="2">
                                </div>
                                <div class="slider-labels">
                                    <span>0.5s</span>
                                    <span>8s</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label" for="filter-freq">Filter Frequency</label>
                            <div class="slider-container">
                                <div class="slider-wrapper">
                                    <input type="range" id="filter-freq" min="200" max="8000" step="50" value="2000">
                                </div>
                                <div class="slider-labels">
                                    <span>200 Hz</span>
                                    <span>8000 Hz</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings section -->
        <div class="control-section" id="settings-section">
            <div class="section-header" onclick="toggleSection('settings')">
                <div class="section-title">
                    <div class="section-icon settings-icon">⚙️</div>
                    <div>
                        <div class="section-info">Settings</div>
                    </div>
                </div>
                <button class="expand-btn" id="settings-expand">
                    <span>▼</span>
                </button>
            </div>
            <div class="section-content" id="settings-content">
                <div class="control-group">
                    <label class="control-label" for="volume">Master Volume</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="volume" min="-30" max="0" step="1" value="-15">
                        </div>
                        <div class="slider-labels">
                            <span>🔇 Quiet</span>
                            <span>Loud 🔊</span>
                        </div>
                    </div>
                </div>

                <div class="control-group" id="settings-random-interval">
                    <label class="control-label" for="random-interval">Random Change Interval</label>
                    <div class="slider-container">
                        <div class="slider-wrapper">
                            <input type="range" id="random-interval" min="1" max="30" step="1" value="10">
                        </div>
                        <div class="slider-labels">
                            <span>1 min</span>
                            <span>30 min</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Playback Controls -->
    <div class="playback-controls">
        <button class="play-button" id="start">Generate Music</button>
        <button class="stop-button" id="stop" disabled>Stop Music</button>
    </div>

    <!-- Visualizer -->
    <div class="visualizer" id="waves">
    </div>

    <div class="info">
        <p>By <a href="https://github.com/mrbarge/mood">mrbarge</a>, with ❤️ to <a href="https://tonejs.github.io/">tone.js</a></p>
    </div>
</div>

<script>

    class OceanWaveSystem {
        constructor() {
            this.isActive = false;
            this.noise = null;
            this.gain = null;
            this.filter = null;
            this.waveTimeout = null;
            this.currentWavePhase = 'waiting';
            this.currentNoiseType = 'pink';
            this.waveStartTime = 0;
            this.waveDuration = 0;
        }

        async init() {
            // Create gain node
            this.gain = new Tone.Gain(parseFloat(baseLevelSlider.value));

            // Create filter with user-controlled frequency
            this.filter = new Tone.Filter(parseInt(filterFreqSlider.value), 'lowpass');

            // Create noise source
            this.noise = new Tone.Noise(this.currentNoiseType);

            // Create wave-specific reverb
            this.waveReverb = new Tone.Reverb({
                decay: 3,
                wet: 0.4,
                preDelay: 0.02
            });

            // Connect the audio chain
            this.noise.connect(this.filter);
            this.filter.connect(this.gain);
            this.gain.connect(this.waveReverb);
            this.waveReverb.connect(masterVolume);

            // Set initial volume from slider
            this.updateVolume();
        }

        start() {
            if (this.isActive) return;

            this.isActive = true;
            if (this.noise) {
                this.noise.start();
                this.scheduleNextWave();
            }
        }

        stop() {
            if (!this.isActive) return;

            this.isActive = false;
            this.currentWavePhase = 'waiting';

            if (this.waveTimeout) {
                clearTimeout(this.waveTimeout);
                this.waveTimeout = null;
            }

            if (this.noise) {
                this.noise.stop();
            }
        }

        dispose() {
            this.stop();
            if (this.noise) this.noise.dispose();
            if (this.gain) this.gain.dispose();
            if (this.filter) this.filter.dispose();
            if (this.waveReverb) this.waveReverb.dispose();
        }

        scheduleNextWave() {
            if (!this.isActive) return;

            // Use pause between setting with random variation
            const pauseDuration = parseFloat(pauseBetweenSlider.value);
            const randomPause = pauseDuration + (Math.random() - 0.5) * pauseDuration * 0.5;

            this.currentWavePhase = 'waiting';

            this.waveTimeout = setTimeout(() => {
                if (this.isActive) this.startWave();
            }, randomPause * 1000);
        }

        startWave() {
            if (!this.isActive) return;

            // Get current slider values
            const minDur = parseFloat(minDurationSlider.value);
            const maxDur = parseFloat(maxDurationSlider.value);
            const baseLevel = parseFloat(baseLevelSlider.value);
            const peakLevel = parseFloat(peakLevelSlider.value);
            const buildSpeed = parseFloat(buildSpeedSlider.value);

            // Random wave duration within specified range
            this.waveDuration = minDur + Math.random() * (maxDur - minDur);
            this.waveStartTime = Tone.now();

            // Calculate phase durations based on build speed
            const speedFactor = buildSpeed / 2.5; // Normalize around default value of 2.5
            const buildTime = this.waveDuration * (0.15 + Math.random() * 0.25) * (1 / speedFactor); // Faster speed = shorter build
            const sustainTime = this.waveDuration * (0.1 + Math.random() * 0.2); // 10-30% of total
            const recedeTime = this.waveDuration - buildTime - sustainTime; // remainder

            this.currentWavePhase = 'building';

            // Build phase - use peak level with variation
            const peakVariation = peakLevel * (0.8 + Math.random() * 0.4); // ±20% variation
            this.gain.gain.rampTo(peakVariation, buildTime);

            // Schedule sustain phase
            setTimeout(() => {
                if (!this.isActive) return;
                this.currentWavePhase = 'sustaining';

                // Add some subtle variation during sustain
                const sustainVariation = peakVariation * (0.9 + Math.random() * 0.2);
                this.gain.gain.rampTo(sustainVariation, sustainTime * 0.5);

                // Schedule recede phase
                setTimeout(() => {
                    if (!this.isActive) return;
                    this.currentWavePhase = 'receding';

                    // Recede to base level (with slight variation)
                    const newBaseLevel = baseLevel * (0.5 + Math.random() * 1);
                    this.gain.gain.rampTo(newBaseLevel, recedeTime);

                    // Schedule next wave
                    setTimeout(() => {
                        if (this.isActive) this.scheduleNextWave();
                    }, recedeTime * 1000);

                }, sustainTime * 1000);

            }, buildTime * 1000);
        }

        updateVolume() {
            if (this.gain) {
                // Convert dB slider to linear gain and apply it
                const dbValue = parseInt(noiseVolumeSlider.value);
                // Use gain.gain instead of gain.volume
                this.gain.gain.rampTo(Tone.dbToGain(dbValue), 0.1);
            }
        }

        updateNoiseType(type) {
            this.currentNoiseType = type;

            if (this.isActive && this.noise) {
                // Recreate noise with new type
                this.noise.stop();
                this.noise.dispose();
                this.noise = new Tone.Noise(type);
                this.noise.connect(this.filter);
                this.noise.start();
            }
        }

        updateFilter(frequency) {
            if (this.filter) {
                this.filter.frequency.rampTo(frequency || parseInt(filterFreqSlider.value), 0.5);
            }
        }

        updateBaseLevel() {
            // This affects the next wave cycle, not the current one
            if (this.currentWavePhase === 'waiting' && this.gain) {
                const baseLevel = parseFloat(baseLevelSlider.value);
                this.gain.gain.rampTo(baseLevel, 1);
            }
        }

        getCurrentIntensity() {
            return this.gain ? this.gain.gain.value : 0;
        }

        getWaveInfo() {
            if (!this.isActive) return 'Stopped';

            switch(this.currentWavePhase) {
                case 'waiting':
                    return 'Waiting for next wave...';
                case 'building':
                    return `Building wave (${this.waveDuration.toFixed(1)}s total)`;
                case 'sustaining':
                    return 'Wave sustaining...';
                case 'receding':
                    return 'Wave receding...';
                default:
                    return 'Wave active';
            }
        }
    }

    // Initialize wave visualizer elements
    function initializeWaves() {
        const wavesContainer = document.getElementById('waves');
        for (let i = 0; i < 40; i++) {
            const wave = document.createElement('div');
            wave.className = 'wave';
            wavesContainer.appendChild(wave);
        }
    }

    // Toggle section expansion
    function toggleSection(sectionName) {
        const section = document.getElementById(`${sectionName}-section`);
        const content = document.getElementById(`${sectionName}-content`);
        const expandBtn = document.getElementById(`${sectionName}-expand`);

        const isExpanded = section.classList.contains('expanded');

        if (isExpanded) {
            section.classList.remove('expanded');
            content.classList.remove('expanded');
            expandBtn.classList.remove('expanded');
        } else {
            section.classList.add('expanded');
            content.classList.add('expanded');
            expandBtn.classList.add('expanded');
        }
    }

    // Update status displays
    function updateMoodStatus() {
        const mood = document.getElementById('mood');
        const status = document.getElementById('mood-status');
        status.textContent = mood.options[mood.selectedIndex].text;
    }

    function updateMelodyStatus() {
        const instrument = document.getElementById('melodic-instrument');
        const status = document.getElementById('melody-status');
        status.textContent = instrument.options[instrument.selectedIndex].text;
    }

    function updateWavesStatus() {
        const toggle = document.getElementById('noise-toggle');
        const status = document.getElementById('waves-status');
        status.textContent = toggle.checked ? 'On' : 'Off';
    }

    // Dice randomizer
    function randomizeEverything() {
        const diceButton = document.getElementById('dice-button');

        // Add visual feedback
        diceButton.style.transform = 'scale(0.95)';
        diceButton.innerHTML = '<span class="dice-icon">🎲</span> Rolling...';

        setTimeout(() => {
            // Randomize mood
            const moodSelect = document.getElementById('mood');
            const moodOptions = Array.from(moodSelect.options).filter(option => option.value !== 'random');
            const randomMood = moodOptions[Math.floor(Math.random() * moodOptions.length)];
            moodSelect.value = randomMood.value;

            // Randomize melody
            const melodySelect = document.getElementById('melodic-instrument');
            const melodyOptions = Array.from(melodySelect.options);
            const randomMelody = melodyOptions[Math.floor(Math.random() * melodyOptions.length)];
            melodySelect.value = randomMelody.value;

            // Randomize waves
            const wavesToggle = document.getElementById('noise-toggle');
            wavesToggle.checked = Math.random() > 0.5;

            // Randomize some sliders
            document.getElementById('density').value = Math.floor(Math.random() * 8) + 2;
            document.getElementById('reverb').value = (Math.random() * 0.8 + 0.2).toFixed(1);
            document.getElementById('melodic-frequency').value = Math.floor(Math.random() * 8) + 2;

            // Apply changes gradually if music is playing
            if (isPlaying) {
                applySettingsGradually();
            }

            // Update status displays
            updateMoodStatus();
            updateMelodyStatus();
            updateWavesStatus();

            // Reset button
            diceButton.style.transform = 'scale(1)';
            diceButton.innerHTML = '<span class="dice-icon">🎲</span> Randomize Everything';
        }, 500);
    }

    // Event listeners
    document.getElementById('dice-button').addEventListener('click', randomizeEverything);

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        initializeWaves();
        updateMoodStatus();
        updateMelodyStatus();
        updateWavesStatus();
    });

    // Initialize variables
    let isPlaying = false;
    let activeNotes = {};
    let synths = [];
    let visualizerInterval = null;
    let currentActiveMood = "calm"; // Default starting mood

    // Create audio context and effects
    const masterVolume = new Tone.Volume(-15).toDestination();

    const reverb = new Tone.Reverb({
        decay: 10,
        wet: 0.5,
        preDelay: 0.01
    }).connect(masterVolume);

    const delay = new Tone.FeedbackDelay({
        delayTime: "8n",
        feedback: 0.4,
        wet: 0.3
    }).connect(reverb);

    const filter = new Tone.Filter({
        type: "lowpass",
        frequency: 2000,
        Q: 1
    }).connect(delay);

    // Initialize UI elements
    const startButton = document.getElementById("start");
    const stopButton = document.getElementById("stop");
    const moodSelect = document.getElementById("mood");
    const densitySlider = document.getElementById("density");
    const reverbSlider = document.getElementById("reverb");
    const wavesContainer = document.getElementById("waves");

    // Melody
    const melodyToggle = document.getElementById("melody-toggle");
    const melodicInstrumentSelect = document.getElementById("melodic-instrument");
    const melodicFrequencySlider = document.getElementById("melodic-frequency");
    const melodicReverbSlider = document.getElementById("melodic-reverb");

    // Control random-ness
    let randomMelodyInterval = null;
    const randomIntervalSlider = document.getElementById("random-interval");
    const randomIntervalContainer = document.getElementById("random-interval-container");

    let waveSystem = null;
    const noiseToggle = document.getElementById("noise-toggle");
    const noiseVolumeSlider = document.getElementById("noise-volume");

    // Wave characteristic controls
    const baseLevelSlider = document.getElementById("base-level");
    const peakLevelSlider = document.getElementById("peak-level");
    const buildSpeedSlider = document.getElementById("build-speed");

    // Timing controls
    const minDurationSlider = document.getElementById("min-duration");
    const maxDurationSlider = document.getElementById("max-duration");
    const pauseBetweenSlider = document.getElementById("pause-between");

    // Audio controls
    const noiseTypeSelect = document.getElementById("noise-type");
    const filterFreqSlider = document.getElementById("filter-freq");

    // Create wave elements for visualizer
    for (let i = 0; i < 40; i++) {
        const wave = document.createElement("div");
        wave.className = "wave";
        wavesContainer.appendChild(wave);
    }

    // Event listeners
    startButton.addEventListener("click", startMusic);
    stopButton.addEventListener("click", stopMusic);
    reverbSlider.addEventListener("input", (e) => {
        reverb.wet.value = parseFloat(e.target.value);
    });

    const volumeSlider = document.getElementById("volume");
    volumeSlider.addEventListener("input", (e) => {
        masterVolume.volume.value = parseInt(e.target.value);
    });

    noiseToggle.addEventListener("change", toggleWaves);
    noiseVolumeSlider.addEventListener("input", updateWaveVolume);

    // Wave characteristic listeners
    baseLevelSlider.addEventListener("input", () => {
        if (waveSystem) waveSystem.updateBaseLevel();
    });
    peakLevelSlider.addEventListener("input", updateWaveSettings);
    buildSpeedSlider.addEventListener("input", updateWaveSettings);

    // Timing listeners
    minDurationSlider.addEventListener("input", updateWaveSettings);
    maxDurationSlider.addEventListener("input", updateWaveSettings);
    pauseBetweenSlider.addEventListener("input", updateWaveSettings);

    // Audio listeners
    noiseTypeSelect.addEventListener("change", updateNoiseType);
    filterFreqSlider.addEventListener("input", () => {
        if (waveSystem) waveSystem.updateFilter();
    });

    melodyToggle.addEventListener("change", toggleMelody);
    melodicReverbSlider.addEventListener("input", function() {
        const reverbAmount = parseFloat(this.value);
        console.debug("Setting melodic reverb to:", reverbAmount);

        // Handle different reverb nodes for different instruments
        if (synths.length > 4) {
            const melodicSynth = synths[4];

            if (melodicSynth.reverbNode) {
                // Sampled piano with its own reverb
                melodicSynth.reverbNode.wet.value = reverbAmount;
            } else if (melodicReverbNode) {
                // Synthesized instruments with shared reverb
                melodicReverbNode.wet.value = reverbAmount;
            }
        }
    });
    melodicInstrumentSelect.addEventListener("change", function() {
        // If we're currently playing, handle instrument change
        if (isPlaying) {
            handleInstrumentChange();
        }
    });

    moodSelect.addEventListener("change", function() {
        if (isPlaying) {
            handleMoodChange();
        }
    });

    // Scale definitions for different moods
    const scales = {
        calm: ["C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4", "C5"],
        ethereal: ["D3", "F#3", "A3", "B3", "D4", "F#4", "A4", "B4", "D5"],
        mysterious: ["C3", "D#3", "F3", "G#3", "B3", "C4", "D#4", "F4", "G#4", "B4"],
        melancholic: ["A2", "C3", "D3", "E3", "F3", "A3", "C4", "D4", "E4", "F4", "A4"],
        hopeful: ["G3", "A3", "B3", "D4", "E4", "G4", "A4", "B4", "D5", "E5"],
        dreamy: ["C3", "D3", "E3", "F#3", "G3", "A3", "B3", "C4", "D4", "E4", "F#4", "G4", "A4", "B4", "C5"],
        nostalgic: ["A2", "B2", "C3", "D3", "E3", "F3", "G3", "A3", "B3", "C4", "D4", "E4", "F4", "G4", "A4"],
        peaceful: ["D3", "E3", "F3", "G3", "A3", "B3", "C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5", "D5"],
        mystical: ["E3", "F3", "G3", "A3", "B3", "C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5", "D5", "E5"],
        celestial: ["C3", "D3", "E3", "F#3", "G#3", "A#3", "C4", "D4", "E4", "F#4", "G#4", "A#4", "C5"],
        contemplative: ["A2", "C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5"],
        serene: ["C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5", "G5"],
        wandering: ["G3", "A3", "B3", "C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5", "D5", "E5", "F5", "G5"],
        introspective: ["A2", "B2", "C3", "D3", "E3", "F3", "G#3", "A3", "B3", "C4", "D4", "E4", "F4", "G#4", "A4"],
        minimalist: ["C3", "E3", "G3", "D4", "F4", "A4", "C5", "E5", "G5"],
        suspended: ["C3", "D3", "F3", "G3", "C4", "D4", "F4", "G4", "C5", "D5", "F5"],
        twilight: ["C3", "Eb3", "F3", "Gb3", "G3", "Bb3", "C4", "Eb4", "F4", "Gb4", "G4", "Bb4", "C5"]
    };

    const melodicPatterns = {
        calm: ["E4", "G4", "C5"],
        ethereal: ["F#4", "B4", "D5"],
        mysterious: ["D#4", "G#4", "C5"],
        melancholic: ["C4", "E4", "A4"],
        hopeful: ["B4", "D5", "G4"],
        dreamy: ["E4", "F#4", "A4", "B4"],
        nostalgic: ["C4", "E4", "F4", "A4"],
        peaceful: ["D4", "F4", "A4", "C5"],
        mystical: ["F4", "G4", "C5", "D5"],
        celestial: ["D4", "F#4", "A#4", "C5"],
        contemplative: ["C4", "E4", "G4"],
        serene: ["E4", "G4", "C5"],
        wandering: ["G4", "C5", "F5"],
        introspective: ["E4", "F4", "G#4"],
        minimalist: ["E4", "G4"],
        suspended: ["D4", "F4", "G4"],
        twilight: ["Eb4", "Gb4", "Bb4"]
    };
    let melodicReverbNode = null;

    // Scale randomization
    let randomScaleInterval = null;

    // Synth presets
    function createPad() {
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 3,
                decay: 2,
                sustain: 0.8,
                release: 8
            }
        }).connect(filter);

        // Add custom methods for cleanup
        synth.timeout = null;
        return synth;
    }

    function createChimes() {
        const synth = new Tone.PolySynth(Tone.FMSynth, {
            harmonicity: 8,
            modulationIndex: 2,
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.1,
                decay: 2,
                sustain: 0.1,
                release: 2
            },
            modulation: {
                type: "square"
            },
            modulationEnvelope: {
                attack: 0.5,
                decay: 0.5,
                sustain: 0.2,
                release: 2
            }
        }).connect(filter);

        // Add custom methods for cleanup
        synth.timeout = null;
        return synth;
    }

    function createBass() {
        const synth = new Tone.MonoSynth({
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.1,
                decay: 0.3,
                sustain: 0.9,
                release: 5
            },
            filterEnvelope: {
                attack: 0.1,
                decay: 0.2,
                sustain: 0.9,
                release: 5,
                baseFrequency: 200,
                octaves: 2.5
            }
        }).connect(filter);

        // Add custom methods for cleanup
        synth.timeout = null;
        return synth;
    }

    // Function to create different melodic instruments
    function createMelodicInstrument(type) {
        let synth;

        switch(type) {

            case "piano":
                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 0.02,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 1
                    }
                });
                break;

            case "idm-electronic":
                // Create a complex FM synth for IDM character
                synth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 2.1,      // Slightly detuned harmonics
                    modulationIndex: 8,    // Heavy modulation
                    oscillator: {
                        type: "sawtooth"   // Bright, digital character
                    },
                    envelope: {
                        attack: 0.001,     // Very fast attack
                        decay: 0.3,
                        sustain: 0.4,
                        release: 2
                    },
                    modulation: {
                        type: "square"     // Digital modulation
                    },
                    modulationEnvelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.3,
                        release: 1.5
                    },
                    volume: -1
                });

                // IDM Effects Chain

                // 1. Bit crusher for digital artifacts
                const idmBitCrusher = new Tone.BitCrusher({
                    bits: 6,           // Lo-fi digital sound
                    wet: 0.3
                });

                // 2. Ring modulator for metallic, alien textures
                const idmRingMod = new Tone.FrequencyShifter({
                    frequency: 47,     // Slightly detuned for weirdness
                    wet: 0.25
                });

                // 3. Phaser for movement and sweep
                const idmPhaser = new Tone.Phaser({
                    frequency: 0.7,    // Slow sweep
                    depth: 0.8,        // Deep modulation
                    baseFrequency: 400,
                    wet: 0.6
                });

                // 4. Granular-style choppy delay
                const idmChopDelay = new Tone.PingPongDelay({
                    delayTime: "16n",
                    feedback: 0.6,     // Higher feedback for IDM character
                    wet: 0.4
                });

                // 5. Filtered feedback delay
                const idmFilteredDelay = new Tone.FeedbackDelay({
                    delayTime: "8n.",
                    feedback: 0.5,
                    wet: 0.3
                });

                // 6. Resonant filter with LFO modulation
                const idmFilter = new Tone.Filter({
                    frequency: 1200,
                    type: "bandpass",
                    Q: 8,              // High resonance
                    rolloff: -24
                });

                // 7. Filter LFO for sweeping movement
                const idmFilterLFO = new Tone.LFO({
                    frequency: 0.13,   // Slow irregular sweep
                    min: 400,
                    max: 2400,
                    type: "triangle"
                });

                // 8. Distortion for grit
                const idmDistortion = new Tone.Distortion({
                    distortion: 0.4,
                    wet: 0.3
                });

                // 9. Chorus for width and shimmer
                const idmChorus = new Tone.Chorus({
                    frequency: 1.2,
                    delayTime: 2,
                    depth: 0.4,
                    wet: 0.35
                }).start();

                // 10. Compressor to glue it together
                const idmCompressor = new Tone.Compressor({
                    threshold: -18,
                    ratio: 4,
                    attack: 0.001,
                    release: 0.2
                });

                // 11. Final reverb
                const idmReverb = new Tone.Reverb({
                    decay: 8,
                    wet: parseFloat(document.getElementById("melodic-reverb").value) * 0.8, // Less reverb than other instruments
                    preDelay: 0.02,
                    roomSize: 0.7
                });

                // Connect the complex effects chain
                synth.connect(idmBitCrusher);
                idmBitCrusher.connect(idmRingMod);
                idmRingMod.connect(idmDistortion);
                idmDistortion.connect(idmPhaser);
                idmPhaser.connect(idmChopDelay);
                idmChopDelay.connect(idmFilteredDelay);
                idmFilteredDelay.connect(idmFilter);
                idmFilter.connect(idmChorus);
                idmChorus.connect(idmCompressor);
                idmCompressor.connect(idmReverb);
                idmReverb.connect(masterVolume);

                // Connect filter LFO
                idmFilterLFO.connect(idmFilter.frequency);
                idmFilterLFO.start();

                // Store effect nodes for potential control or disposal
                synth.reverbNode = idmReverb;
                synth.filterLFO = idmFilterLFO;
                synth.effectNodes = [idmBitCrusher, idmRingMod, idmPhaser, idmChopDelay,
                    idmFilteredDelay, idmFilter, idmDistortion, idmChorus, idmCompressor];

                break;

            case "sampled-piano":
                // Create sampled piano using publicly available samples
                synth = new Tone.Sampler({
                    urls: {
                        "C4": "C4.mp3",
                        "D#4": "Ds4.mp3",
                        "F#4": "Fs4.mp3",
                        "A4": "A4.mp3",
                        "C5": "C5.mp3",
                        "D#5": "Ds5.mp3",
                        "F#5": "Fs5.mp3",
                        "A5": "A5.mp3",
                    },
                    release: 1,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                    volume: 0  // Increased from -8 to -2 for more presence
                });

                // Create ambient effects chain for piano

                // 1. Chorus for richness and movement
                const pianoChorus = new Tone.Chorus({
                    frequency: 0.5,  // Slow modulation
                    delayTime: 3.5,  // Deeper chorus effect
                    depth: 0.3,      // Moderate depth
                    wet: 0.4         // 40% wet signal
                }).start();

                // 2. Stereo widener using ping-pong delay
                const pianoStereoDelay = new Tone.PingPongDelay({
                    delayTime: "16n",    // Very short delay
                    feedback: 0.1,       // Minimal feedback
                    wet: 0.3            // Subtle stereo widening
                });

                // 3. Longer delay for ambient tails
                const pianoAmbientDelay = new Tone.FeedbackDelay({
                    delayTime: "4n.",    // Dotted quarter note
                    feedback: 0.3,       // Moderate feedback
                    wet: 0.25           // 25% wet
                });

                // 4. Low-pass filter to soften harsh frequencies
                const pianoFilter = new Tone.Filter({
                    frequency: 4000,     // Cut above 4kHz
                    type: "lowpass",
                    rolloff: -12        // Gentle slope
                });

                // 5. Compressor for even dynamics
                const pianoCompressor = new Tone.Compressor({
                    threshold: -20,
                    ratio: 3,
                    attack: 0.003,
                    release: 0.1
                });

                // 6. Large reverb for spaciousness
                const pianoReverb = new Tone.Reverb({
                    decay: 12,          // Very long decay
                    wet: parseFloat(document.getElementById("melodic-reverb").value),
                    preDelay: 0.05,     // Slight pre-delay for separation
                    roomSize: 0.9       // Large room
                });

                // 7. Optional: Subtle tremolo for movement
                const pianoTremolo = new Tone.Tremolo({
                    frequency: 0.3,     // Very slow tremolo
                    depth: 0.1,         // Subtle depth
                    wet: 0.6           // Mix it in
                }).start();

                // Connect the effects chain
                synth.connect(pianoChorus);
                pianoChorus.connect(pianoStereoDelay);
                pianoStereoDelay.connect(pianoAmbientDelay);
                pianoAmbientDelay.connect(pianoFilter);
                pianoFilter.connect(pianoCompressor);
                pianoCompressor.connect(pianoTremolo);
                pianoTremolo.connect(pianoReverb);
                pianoReverb.connect(masterVolume);

                // Store effect nodes for potential control
                synth.reverbNode = pianoReverb;
                synth.chorusNode = pianoChorus;
                synth.filterNode = pianoFilter;
                synth.tremoloNode = pianoTremolo;
                synth.delayNode = pianoAmbientDelay;

                break;

            case "marimba":
                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.5,
                        sustain: 0,
                        release: 0.1
                    }
                });
                break;

            case "harp":
                // Use FMSynth instead which is compatible with PolySynth
                synth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.5,
                    modulationIndex: 10,
                    oscillator: {
                        type: "sine"
                    },
                    envelope: {
                        attack: 0.01,
                        decay: 0.7,
                        sustain: 0.1,
                        release: 1
                    },
                    modulation: {
                        type: "triangle"
                    },
                    modulationEnvelope: {
                        attack: 0.05,
                        decay: 0.5,
                        sustain: 0.2,
                        release: 0.5
                    },
                    volume: -5
                });
                break;

            case "music-box":
                synth = new Tone.PolySynth(Tone.MetalSynth, {
                    harmonicity: 3.1,
                    resonance: 1000,
                    modulationIndex: 12,
                    envelope: {
                        attack: 0.001,
                        decay: 1,
                        sustain: 0,
                        release: 0.5
                    },
                    volume: -25
                });
                break;

            default:
                return null;
        }

        // Only add effects chain for non-sampled instruments
        if (type === "sampled-piano") {
            // Sampled piano gets simpler processing
            const sampledPianoReverb = new Tone.Reverb({
                decay: 8,
                wet: parseFloat(document.getElementById("melodic-reverb").value),
                preDelay: 0.02
            });

            synth.connect(sampledPianoReverb);
            sampledPianoReverb.connect(masterVolume);

            // Store reverb reference for control
            synth.reverbNode = sampledPianoReverb;
        } else {
            // Existing effect chain for synthesized instruments
            const pingPongDelay = new Tone.PingPongDelay({
                delayTime: "8n",
                feedback: 0.3,
                wet: 0.25
            });

            melodicReverbNode = new Tone.Reverb({
                decay: 10,
                wet: parseFloat(document.getElementById("melodic-reverb").value),
                preDelay: 0.03
            });

            synth.connect(pingPongDelay);
            pingPongDelay.connect(melodicReverbNode);
            melodicReverbNode.connect(masterVolume);
        }

        // Add custom property for cleanup
        synth.timeout = null;

        return synth;
    }

    // Function to schedule melodic phrases
    function scheduleMelodicPhrases(synth, scale, patternStartNotes, instrumentType) {
        const playMelody = () => {
            if (!isPlaying) return;

            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }

            // Create a short melodic phrase
            const phraseLength = Math.floor(Math.random() * 5) + 3; // 3-7 notes
            const startNote = patternStartNotes[Math.floor(Math.random() * patternStartNotes.length)];
            const startIndex = scale.indexOf(startNote);

            if (startIndex !== -1) {
                // Generate melody based on scale steps
                const melody = [];
                let currentIndex = startIndex;

                // Add the first note
                melody.push(scale[currentIndex]);

                // Generate the rest of the phrase
                for (let i = 1; i < phraseLength; i++) {
                    // Calculate a step between -2 and +2 in the scale
                    const step = Math.floor(Math.random() * 5) - 2;
                    currentIndex = Math.min(Math.max(0, currentIndex + step), scale.length - 1);
                    melody.push(scale[currentIndex]);
                }

                // ADD THE IDM MODIFICATIONS HERE - AFTER melody generation, BEFORE playMelodicSequence
                if (instrumentType === "idm-electronic") {
                    // IDM-style modifications to the melody
                    const modifiedMelody = melody.map(note => {
                        // Occasionally transpose notes to different octaves
                        if (Math.random() < 0.3) {
                            const noteBase = note.slice(0, -1);
                            const octave = parseInt(note.slice(-1));
                            const newOctave = Math.random() < 0.5 ?
                                Math.max(2, octave - 1) :
                                Math.min(6, octave + 1);
                            return noteBase + newOctave;
                        }
                        return note;
                    });

                    // Play the modified melody with IDM timing variations
                    playMelodicSequence(synth, modifiedMelody, instrumentType);
                } else {
                    // Play the melody with varying timing (existing code)
                    playMelodicSequence(synth, melody, instrumentType);
                }
            }

            // Calculate next phrase time based on frequency setting
            const frequency = parseInt(melodicFrequencySlider.value);
            const baseTime = (11 - frequency) * 6; // Higher frequency means shorter time
            const randomFactor = Math.random() * 10;
            const nextPhraseTime = (baseTime + randomFactor) * 1000;

            // Schedule next phrase only if we're still playing
            if (isPlaying) {
                synth.timeout = setTimeout(playMelody, nextPhraseTime);
            }
        };

        // Start melodic phrases after a delay
        if (isPlaying) {
            synth.timeout = setTimeout(playMelody, Math.random() * 5000 + 10000); // 10-15 second initial delay
        }
    }

    // Function to play a sequence of notes as a melodic phrase
    function playMelodicSequence(synth, melody, instrumentType) {
        // Different timing patterns for different instruments
        let noteDuration, noteSpacing;

        switch(instrumentType) {
            case "piano":
                noteDuration = 1.5;
                noteSpacing = 0.8;
                break;
            case "sampled-piano":
                noteDuration = 2.0;  // Longer sustain for realistic piano
                noteSpacing = 1.0;   // More space between notes
                break;
            case "marimba":
                noteDuration = 0.5;
                noteSpacing = 0.6;
                break;
            case "harp":
                noteDuration = 1.0;
                noteSpacing = 0.7;
                break;
            case "music-box":
                noteDuration = 0.3;
                noteSpacing = 0.4;
                break;
            case "idm-electronic":
                noteDuration = 0.8;     // Shorter, punchier notes
                noteSpacing = 0.9;      // Slightly irregular spacing
                break;
            default:
                noteDuration = 1.0;
                noteSpacing = 0.7;
        }

        // Play each note in the melody
        melody.forEach((note, index) => {
            // Calculate timing with IDM variations
            let timing = index * noteSpacing * 1000;

            if (instrumentType === "idm-electronic") {
                // Add more dramatic timing variations for IDM
                timing += (Math.random() * 0.6 - 0.3) * 1000; // ±300ms variation
                timing = Math.max(0, timing); // Ensure no negative timing
            } else {
                // Standard slight timing variations
                timing += (Math.random() * 0.2 * 1000);
            }
            setTimeout(() => {
                try {
                    if (!isPlaying) return;

                    if (!activeNotes[note]) {
                        activeNotes[note] = {
                            count: 1,
                            type: 'melodic'
                        };
                    } else {
                        activeNotes[note].count++;
                    }

                    // Different trigger methods for different instruments
                    if (instrumentType === "sampled-piano") {
                        // Sampled instruments need time to load
                        if (synth.loaded) {
                            synth.triggerAttackRelease(note, noteDuration);
                        } else {
                            // Wait for samples to load, then play
                            synth.loaded.then(() => {
                                if (isPlaying) {
                                    synth.triggerAttackRelease(note, noteDuration);
                                }
                            });
                        }
                    } else {
                        // Regular synths
                        synth.triggerAttackRelease(note, noteDuration);
                    }

                    // Remove note from active notes after it ends
                    setTimeout(() => {
                        if (isPlaying && activeNotes[note]) {
                            activeNotes[note].count--;
                            if (activeNotes[note].count <= 0) {
                                delete activeNotes[note];
                            }
                        }
                    }, noteDuration * 1000 + 500);
                } catch (error) {
                    console.log("Note playback error (ignored):", error.message);
                }
            }, timing); // This is the existing timing
        });
    }

    // Function to handle instrument changes during playback
    function handleInstrumentChange() {
        // Clear any existing random interval
        if (randomMelodyInterval) {
            clearInterval(randomMelodyInterval);
            randomMelodyInterval = null;
        }

        // Get the currently selected instrument
        const selectedInstrument = melodicInstrumentSelect.value;
        console.debug("Instrument changed to:", selectedInstrument);

        // If it's a specific instrument (not random or none)
        if (selectedInstrument !== "random" && melodyToggle.checked) {
            // Remove any existing melodic synth
            if (synths.length > 4) {
                const oldSynth = synths.pop();
                if (oldSynth && oldSynth.timeout) {
                    clearTimeout(oldSynth.timeout);
                }
                setTimeout(() => {
                    if (oldSynth) oldSynth.dispose();
                }, 500);
            }

            // Create new synth with selected instrument
            const melodicSynth = createMelodicInstrument(selectedInstrument);
            if (melodicSynth) {
                synths.push(melodicSynth);
                melodicSynth.volume.value = -5;

                // Get current scale and start scheduling
                const effectiveMood = moodSelect.value === "random" ? currentActiveMood : moodSelect.value;
                const currentScale = scales[effectiveMood];
                const melodicPattern = melodicPatterns[effectiveMood];

                scheduleMelodicPhrases(melodicSynth, currentScale, melodicPattern, selectedInstrument);
            }
        }
        // If it's set to random, start the random cycling
        else if (selectedInstrument === "random") {
            startRandomInstrumentCycle();
        }
        // If it's none, remove the melodic synth if it exists
        else if (!melodyToggle.checked) {
            if (synths.length > 4) {
                const oldSynth = synths.pop();
                if (oldSynth && oldSynth.timeout) {
                    clearTimeout(oldSynth.timeout);
                }
                setTimeout(() => {
                    if (oldSynth) oldSynth.dispose();
                }, 500);
            }
        }
    }

    // Function to handle mood changes
    function handleMoodChange() {
        // Clear any existing random interval
        if (randomScaleInterval) {
            clearInterval(randomScaleInterval);
            randomScaleInterval = null;
        }

        const selectedMood = moodSelect.value;
        console.debug("Mood changed to:", selectedMood);

        if (selectedMood !== "random") {
            // Update all synths with the new scale
            currentActiveMood = selectedMood;
            const newScale = scales[selectedMood];
            updateAllSynthsWithNewScale(newScale, selectedMood);
        } else {
            // Start random scale cycling
            startRandomScaleCycle();
        }
    }

    // Function to start random instrument cycling
    function startRandomInstrumentCycle() {
        console.debug("Starting random instrument cycle");

        // Clear any existing interval
        if (randomMelodyInterval) {
            clearInterval(randomMelodyInterval);
        }

        // Change to a random instrument initially
        changeToRandomInstrument();

        // Set up the interval for future changes
        const minutesValue = parseInt(randomIntervalSlider.value);
        const milliseconds = minutesValue * 60 * 1000; // Convert minutes to milliseconds

        console.debug(`Setting random instrument interval to ${minutesValue} minutes (${milliseconds}ms)`);
        randomMelodyInterval = setInterval(() => {
            if (isPlaying && melodicInstrumentSelect.value === "random") {
                changeToRandomInstrument();
            } else {
                // If no longer in random mode or not playing, clear the interval
                clearInterval(randomMelodyInterval);
                randomMelodyInterval = null;
            }
        }, milliseconds);
    }

    // Function to change to a random instrument
    function changeToRandomInstrument() {
        // Get all regular instrument options (excluding "none" and "random")
        const instrumentOptions = Array.from(melodicInstrumentSelect.options)
            .filter(option => option.value !== "none" && option.value !== "random")
            .map(option => option.value);

        // Get current actual instrument (or last used if in random mode)
        let currentInstrument = "";
        if (synths.length > 4) {
            currentInstrument = synths[4].instrumentType || ""; // We'll need to store this property
        }

        // Select a random instrument different from the current one
        let newInstrument;
        do {
            const randomIndex = Math.floor(Math.random() * instrumentOptions.length);
            newInstrument = instrumentOptions[randomIndex];
        } while (newInstrument === currentInstrument && instrumentOptions.length > 1);

        console.debug(`Random change: ${currentInstrument} → ${newInstrument}`);

        // Remove current melodic synth if it exists
        if (synths.length > 4) {
            const oldSynth = synths.pop();

            // Clear any pending timeouts
            if (oldSynth.timeout) {
                clearTimeout(oldSynth.timeout);
            }

            // Wait a moment before disposing to let any in-progress notes complete
            setTimeout(() => {
                try {
                    oldSynth.dispose();
                } catch (error) {
                    // Silently catch any errors
                    console.debug("Note: synth already disposed");
                }
            }, 500);
        }

        // Create new synth
        const melodicSynth = createMelodicInstrument(newInstrument);
        if (melodicSynth) {
            // Store the instrument type for reference
            melodicSynth.instrumentType = newInstrument;

            synths.push(melodicSynth);
            melodicSynth.volume.value = -5;

            // Get current scale and start scheduling
            const currentMood = moodSelect.value === "random" ? currentActiveMood : moodSelect.value;
            const currentScale = scales[currentMood];
            const melodicPattern = melodicPatterns[currentMood];

            scheduleMelodicPhrases(melodicSynth, currentScale, melodicPattern, newInstrument);
        }
    }

    // Function to start random scale cycling
    function startRandomScaleCycle() {
        // Initial random scale change
        changeToRandomScale();

        // Set up the interval for future changes
        const minutesValue = parseInt(randomIntervalSlider.value);
        const milliseconds = minutesValue * 60 * 1000; // Convert minutes to milliseconds

        randomScaleInterval = setInterval(() => {
            if (isPlaying && moodSelect.value === "random") {
                changeToRandomScale();
            } else {
                // Clear if no longer in random mode
                clearInterval(randomScaleInterval);
                randomScaleInterval = null;
            }
        }, milliseconds);
    }

    // Function to change to a random scale
    function changeToRandomScale() {
        // Get all valid mood options (excluding "random")
        const moodOptions = Array.from(moodSelect.options)
            .filter(option => option.value !== "random")
            .map(option => option.value);

        // Select a random mood
        const randomIndex = Math.floor(Math.random() * moodOptions.length);
        const newMood = moodOptions[randomIndex];

        // Update the current active mood
        currentActiveMood = newMood;

        console.debug("Random mood change to:", currentActiveMood);

        // Get the corresponding scale
        const newScale = scales[currentActiveMood];

        // Update all synths with this scale
        updateAllSynthsWithNewScale(newScale, currentActiveMood);

        return newScale;
    }

    // Function to update all synths with a new scale
    function updateAllSynthsWithNewScale(newScale, mood) {
        // Stop current scheduling
        synths.forEach(synth => {
            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }
        });

        // Get melodic pattern for this mood
        const melodicPattern = melodicPatterns[mood];

        // Restart scheduling with new scale
        schedulePadNotes(synths[0], newScale);

        setTimeout(() => {
            if (isPlaying) {
                schedulePadNotes(synths[1], newScale);
            }
        }, 2000);

        scheduleChimes(synths[2], newScale);
        scheduleBassNotes(synths[3], newScale);

        // Update melodic synth if it exists
        if (synths.length > 4) {
            const melodicSynth = synths[4];
            const instrumentType = melodicSynth.instrumentType || melodicInstrumentSelect.value;

            if (instrumentType !== "none" && instrumentType !== "random") {
                scheduleMelodicPhrases(melodicSynth, newScale, melodicPattern, instrumentType);
            }
        }
    }

    // noise filters
    function createNoiseGenerator() {
        // Create noise source
        const noise = new Tone.Noise({
            type: "pink",
            // type: "brown",
            volume: parseInt(noiseVolumeSlider.value)
        });

        // Create filter for shaping the noise
        const noiseFilter = new Tone.Filter({
            type: "lowpass",
            frequency: 800
        });

        // Create amplitude modulation for wave-like volume changes
        const volumeLFO = new Tone.LFO({
            frequency: 0.05,
            min: -30,
            max: parseInt(noiseVolumeSlider.value),
        });

        // Create a separate reverb with less wet mix for the noise
        const noiseReverb = new Tone.Reverb({
            decay: 2,       // Shorter decay than main reverb
            wet: 0.3,       // Less wet mix
            preDelay: 0.01
        }).connect(masterVolume);

        // Apply EQ to make the ocean waves sound more natural and prominent
        const noiseEQ = new Tone.EQ3({
            low: 2,     // Boost low frequencies (+2 dB)
            mid: -3,    // Cut mids a bit
            high: 1     // Slight high boost
        });
        noise.connect(noiseEQ);
        noiseEQ.connect(noiseFilter);

        const noiseVolume = new Tone.Volume().connect(noiseReverb);

        // Custom volume node to connect the LFO
        volumeLFO.connect(noiseVolume.volume);

        noiseVolume.volume.value = parseInt(noiseVolumeSlider.value);

        // Connect the chain
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseVolume);

        // Start LFOs
        volumeLFO.start();

        // Return objects for later control
        return {
            noise,
            noiseFilter,
            noiseVolume,
            volumeLFO
        };
    }

    // Toggle noise on/off
    function toggleNoise() {
        console.debug("Toggle noise called, checked:", noiseToggle.checked);
        if (noiseToggle.checked) {
            // Start noise if checked and not already running
            console.debug("Creating noise generator");
            if (!noiseSource) {
                console.debug("Starting noise");
                noiseSource = createNoiseGenerator();
                noiseSource.noise.start();
                console.debug("noise volume current value is ", noiseSource.noiseVolume.volume.value);
            }
        } else {
            // Stop noise if unchecked and running
            if (noiseSource) {
                noiseSource.noise.stop();
                noiseSource.volumeLFO.stop();

                // Clean up
                setTimeout(() => {
                    if (noiseSource) {
                        noiseSource.noise.dispose();
                        noiseSource.noiseFilter.dispose();
                        noiseSource.noiseVolume.dispose();
                        noiseSource.volumeLFO.dispose();
                        noiseSource = null;
                    }
                }, 100);
            }
        }
    }

    // Update noise volume
    function updateNoiseVolume() {
        if (noiseSource && noiseSource.volumeLFO) {
            const volume = parseInt(noiseVolumeSlider.value);
            console.debug("Updating noise volume: ", volume, " where current value is ", noiseSource.noiseVolume.volume.value);
            // Set volume directly on the volume node
            noiseSource.noiseVolume.volume.value = volume;
            // Important: We need to make sure this takes effect immediately
            noiseSource.noiseVolume.volume.rampTo(volume, 0.1); // Smooth transition
            noiseSource.volumeLFO.max = volume;
        }
    }

    // Main function to start generating music
    async function startMusic() {
        if (isPlaying) return;

        // Start audio context
        await Tone.start();

        // Reset state
        isPlaying = true;
        activeNotes = {};

        // Update UI
        startButton.disabled = true;
        stopButton.disabled = false;

        // Clean up any previous synths
        synths.forEach(synth => synth.dispose());
        synths = [];

        // Create new synths
        const pad1 = createPad();
        const pad2 = createPad();
        const chimes = createChimes();
        const bass = createBass();

        synths.push(pad1, pad2, chimes, bass);

        // Setup volume levels
        pad1.volume.value = -8;
        pad2.volume.value = -10;
        chimes.volume.value = -15;
        bass.volume.value = -5;

        // Update reverb
        reverb.wet.value = parseFloat(reverbSlider.value);

        // Update master volume
        masterVolume.volume.value = parseInt(volumeSlider.value);

        // Start transport
        Tone.Transport.bpm.value = 60;
        Tone.Transport.start();

        // Initialize currentActiveMood
        if (moodSelect.value !== "random") {
            currentActiveMood = moodSelect.value;
        } else {
            // Pick a random initial mood
            const moodOptions = Array.from(moodSelect.options)
                .filter(option => option.value !== "random")
                .map(option => option.value);

            currentActiveMood = moodOptions[Math.floor(Math.random() * moodOptions.length)];
            console.debug("Starting with random mood:", currentActiveMood);
        }

        // Then use currentActiveMood for initial setup
        const currentScale = scales[currentActiveMood];

        if (moodSelect.value === "random") {
            startRandomScaleCycle();
        }

        // Create melodic instrument if selected
        const selectedInstrument = melodicInstrumentSelect.value;
        // if (selectedInstrument !== "none") {
        if (melodyToggle.checked) {
            if (selectedInstrument === "random") {
                // Start random cycling mode
                startRandomInstrumentCycle();
            } else {
                // Create specific instrument
                const melodicSynth = createMelodicInstrument(selectedInstrument);
                if (melodicSynth) {
                    melodicSynth.instrumentType = selectedInstrument; // Store type
                    synths.push(melodicSynth);
                    melodicSynth.volume.value = -5;

                    const melodicPattern = melodicPatterns[currentActiveMood];
                    scheduleMelodicPhrases(melodicSynth, currentScale, melodicPattern, selectedInstrument);
                }
            }
        }

        // Generate ambient pad sounds
        schedulePadNotes(pad1, currentScale);

        // Wait a bit before adding the second pad for texture
        setTimeout(() => {
            schedulePadNotes(pad2, currentScale);
        }, 5000);

        // Add occasional chime sounds
        scheduleChimes(chimes, currentScale);

        // Add bass notes
        scheduleBassNotes(bass, currentScale);

        // Start visualizer
        startVisualizer();
    }

    function schedulePadNotes(synth, scale) {
        const playNote = () => {
            // Don't schedule more notes if we've stopped playing
            if (!isPlaying) return;

            // Clear previous timeout if exists
            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }

            // Select 1-3 notes from the scale to play as a chord
            const numNotes = Math.floor(Math.random() * 3) + 1;
            const notes = [];

            for (let i = 0; i < numNotes; i++) {
                const note = scale[Math.floor(Math.random() * scale.length)];
                notes.push(note);

                // Track active notes for visualization
                if (!activeNotes[note]) {
                    activeNotes[note] = {
                        count: 1,
                        type: 'pad'
                    };
                } else {
                    activeNotes[note].count++;
                }
            }

            // Play chord
            if (notes.length > 0) {
                synth.triggerAttackRelease(notes, Math.random() * 10 + 8);
            }

            // Calculate next note time based on density
            const density = parseInt(densitySlider.value);
            const baseTime = 11 - density; // Higher density means shorter time between notes
            const randomFactor = Math.random() * 3;
            const nextNoteTime = (baseTime + randomFactor) * 1000;

            // Schedule next note only if we're still playing
            if (isPlaying) {
                synth.timeout = setTimeout(playNote, nextNoteTime);
            }
        };

        // Start the recursive note scheduling
        playNote();
    }

    function scheduleChimes(synth, scale) {
        const playChime = () => {
            // Don't schedule more notes if we've stopped playing
            if (!isPlaying) return;

            // Clear previous timeout if exists
            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }

            // Randomly decide whether to play a note (75% chance)
            if (Math.random() > 0.25) {
                // Select a higher note from the scale
                const highNotes = scale.filter(note => {
                    const octave = parseInt(note.slice(-1));
                    return octave >= 4;
                });

                if (highNotes.length > 0) {
                    const note = highNotes[Math.floor(Math.random() * highNotes.length)];

                    // Add note to active notes
                    if (!activeNotes[note]) {
                        activeNotes[note] = {
                            count: 1,
                            type: 'chime'
                        };
                    } else {
                        activeNotes[note].count++;
                    }

                    // Play the note
                    synth.triggerAttackRelease(note, "16n");

                    // Remove note from active notes after it ends
                    setTimeout(() => {
                        if (isPlaying && activeNotes[note]) {
                            activeNotes[note].count--;
                            if (activeNotes[note].count <= 0) {
                                delete activeNotes[note];
                            }
                        }
                    }, 2000);
                }
            }

            // Calculate next chime time based on density
            const density = parseInt(densitySlider.value);
            const baseTime = (11 - density) * 1.5; // Higher density means shorter time
            const randomFactor = Math.random() * 4;
            const nextChimeTime = (baseTime + randomFactor) * 1000;

            // Schedule next chime only if we're still playing
            if (isPlaying) {
                synth.timeout = setTimeout(playChime, nextChimeTime);
            }
        };

        // Start chimes after a short delay
        if (isPlaying) {
            synth.timeout = setTimeout(playChime, 8000);
        }
    }

    function scheduleBassNotes(synth, scale) {
        const playBass = () => {
            // Don't schedule more notes if we've stopped playing
            if (!isPlaying) return;

            // Clear previous timeout if exists
            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }

            // Select bass notes (lower octaves)
            const bassNotes = scale.filter(note => {
                const octave = parseInt(note.slice(-1));
                return octave <= 3;
            });

            if (bassNotes.length > 0) {
                const note = bassNotes[Math.floor(Math.random() * bassNotes.length)];

                // Add note to active notes
                if (!activeNotes[note]) {
                    activeNotes[note] = {
                        count: 1,
                        type: 'bass'
                    };
                } else {
                    activeNotes[note].count++;
                }

                // Play the note with longer duration
                synth.triggerAttackRelease(note, Math.random() * 6 + 4);
            }

            // Calculate next bass note time
            const nextBassTime = (Math.random() * 10 + 10) * 1000; // 10-20 seconds

            // Schedule next bass note only if we're still playing
            if (isPlaying) {
                synth.timeout = setTimeout(playBass, nextBassTime);
            }
        };

        // Start bass after a delay
        if (isPlaying) {
            synth.timeout = setTimeout(playBass, 2000);
        }
    }

    function stopMusic() {
        isPlaying = false;

        // Stop all synths
        synths.forEach(synth => {
            // Clear any pending timeouts
            if (synth.timeout) {
                clearTimeout(synth.timeout);
                synth.timeout = null;
            }

            // Properly release synth notes
            try {
                if (typeof synth.releaseAll === 'function') {
                    synth.releaseAll();
                } else if (typeof synth.triggerRelease === 'function') {
                    synth.triggerRelease();
                }
            } catch (error) {
                console.error("Error releasing synth:", error);
            }

            // Dispose after a short delay to allow release to complete
            setTimeout(() => {
                try {
                    synth.dispose();
                } catch (error) {
                    console.error("Error disposing synth:", error);
                }
            }, 500);
        });

        // Clear the synths array
        synths = [];

        // Stop transport
        Tone.Transport.stop();

        // Update UI
        startButton.disabled = false;
        stopButton.disabled = true;

        // Stop visualizer
        if (visualizerInterval) {
            clearInterval(visualizerInterval);
            visualizerInterval = null;
        }

        // Clear active notes
        activeNotes = {};

        if (randomMelodyInterval) {
            clearInterval(randomMelodyInterval);
            randomMelodyInterval = null;
        }

        console.log("Music stopped successfully");
    }

    function startVisualizer() {
        // Clear any existing interval
        if (visualizerInterval) {
            clearInterval(visualizerInterval);
        }

        const waves = document.querySelectorAll('.wave');

        visualizerInterval = setInterval(() => {
            // Update each wave based on audio activity
            waves.forEach((wave, index) => {
                if (isPlaying) {

                    // In your startVisualizer function, replace the wave color block:
                    // Change color based on active instruments
                    if (noiseToggle.checked && index % 4 === 0) {
                        // Blue-green for ocean waves
                        wave.style.backgroundColor = `hsla(${180 + Math.random() * 40}, 80%, 70%, 0.2)`;
                    } else if (melodicInstrumentSelect.value !== "none" && index % 5 === 0) {
                        // Gold/yellow for melodic instruments
                        wave.style.backgroundColor = `hsla(${40 + Math.random() * 20}, 90%, 65%, 0.25)`;
                    } else {
                        // Normal color spectrum for other sounds
                        // wave.style.backgroundColor = `hsla(${hue}, 80%, 70%, 0.2)`;

                        // Create random but smooth movements
                        const heightPercent = Math.random() * 50 + 10;
                        wave.style.height = `${heightPercent}%`;

                        // Add some color variation based on active notes
                        const hue = (index * 9) % 360;
                        wave.style.backgroundColor = `hsla(${hue}, 80%, 70%, 0.2)`;

                    }

                } else {
                    wave.style.height = "30%";
                    wave.style.backgroundColor = "rgba(255, 255, 255, 0.2)";
                }
            });
        }, 200);
    }

    function applySettingsGradually() {
        if (!isPlaying) return;

        // Gradually ramp reverb changes instead of instant jumps
        const targetReverb = parseFloat(reverbSlider.value);
        reverb.wet.rampTo(targetReverb, 1.5);

        // Handle mood/scale change during playback
        if (moodSelect.value !== "random") {
            currentActiveMood = moodSelect.value;
            const newScale = scales[currentActiveMood];
            updateAllSynthsWithNewScale(newScale, currentActiveMood);
        }

        // Handle instrument change during playback
        handleInstrumentChange();

        if (noiseToggle.checked && (!waveSystem || !waveSystem.isActive)) {
            toggleWaves(); // Start waves if they weren't on
        } else if (!noiseToggle.checked && waveSystem && waveSystem.isActive) {
            toggleWaves(); // Stop waves if they were on
        }

        // Update all wave system settings if active
        if (waveSystem && waveSystem.isActive) {
            waveSystem.updateVolume();
            waveSystem.updateNoiseType(noiseTypeSelect.value);
            waveSystem.updateFilter();
            waveSystem.updateBaseLevel();
        }
    }

    function toggleMelody(event) {
        // Stop the event from bubbling up to the section header
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }

        updateMelodyStatus();

        // Apply the toggle if music is playing
        if (isPlaying) {
            handleInstrumentChange();
        }
    }

    function updateWaveVolume() {
        if (waveSystem) {
            waveSystem.updateVolume();
        }
    }

    function updateWaveSettings() {
        // Settings like duration, timing, and build speed are applied
        // automatically when the next wave cycle starts.
        // No immediate action needed - the sliders will be read
        // by the wave system when it creates the next wave.

        // Optional: You could add immediate feedback here if desired
        console.debug("Wave settings updated - will apply to next wave cycle");
    }

    function updateNoiseType() {
        const selectedType = noiseTypeSelect.value;
        if (waveSystem) {
            waveSystem.updateNoiseType(selectedType);
            waveSystem.updateFilter(); // Also update filter to match noise type
        }
    }

    // Enhanced toggle waves function (this replaces the old toggleNoise)
    async function toggleWaves() {
        if (noiseToggle.checked) {
            // Initialize and start wave system
            if (!waveSystem) {
                waveSystem = new OceanWaveSystem();
                await waveSystem.init();
            }

            waveSystem.start();
        } else {
            // Stop wave system
            if (waveSystem) {
                waveSystem.stop();
            }
        }
        updateWavesStatus();
    }

</script>
</body>
</html>