class MultiMelodyManager{constructor(){this.registry=new MelodyInstrumentRegistry,this.melodySlots=[],this.isEnabled=!1,this.globalRandomInterval=null,this.maxSlots=3,this.currentSlotCount=1}initializeSlots(t=1){console.debug(`Initializing ${t} melody slots`),this.disposeAllSlots(),this.melodySlots=[];for(let e=0;e<t;e++)this.melodySlots.push(this.createMelodySlot(e));this.currentSlotCount=t}createMelodySlot(t){return{id:t,instrument:null,isActive:!1,config:{instrumentType:"piano",volume:-8-2*t,reverbAmount:.6+.1*t,frequency:3-t,scale:null,pattern:null,randomness:{timing:.3+.2*t,noteChoice:.1+.1*t,octaveShift:t>1?.2:0}},timeout:null,randomCycleTimeout:null}}setSlotCount(t){t<1&&(t=1),t>this.maxSlots&&(t=this.maxSlots);const e=this.isEnabled,o=(this.isSingleSlotMode(),this.melodySlots[0]?.config.scale),n=this.melodySlots[0]?.config.pattern;this.stop(),this.initializeSlots(t),e&&o&&n&&(this.setEnabled(!0),this.setScaleAndPattern(o,n)),console.debug(`Melody slot count changed to: ${t} (single-slot mode: ${this.isSingleSlotMode()})`)}async setSlotInstrument(t,e,o={}){if(t>=this.melodySlots.length)return;const n=this.melodySlots[t];n.isActive&&(n.isActive=!1,n.timeout&&(clearTimeout(n.timeout),n.timeout=null),n.instrument&&n.instrument.stop()),n.instrument&&n.instrument.dispose();n.config;return n.instrument=this.registry.create(e,o),n.config.instrumentType=e,"undefined"!=typeof masterVolume&&"undefined"!=typeof reverb&&await n.instrument.initialize(masterVolume,reverb),console.debug(`Slot ${t} instrument set to: ${e}`),n.instrument}async setAllSlotsToInstrument(t,e={}){console.debug(`Setting all ${this.melodySlots.length} slots to instrument: ${t}`);for(let o=0;o<this.melodySlots.length;o++)await this.setSlotInstrument(o,t,e);console.debug(`All slots set to ${t}, active slots:`,this.melodySlots.filter(t=>t.isActive).length)}async randomizeSlotInstruments(){const t=this.registry.getAvailableInstruments();for(let e=0;e<this.melodySlots.length;e++){const o=t[Math.floor(Math.random()*t.length)];await this.setSlotInstrument(e,o)}console.debug("Randomized all slot instruments")}setEnabled(t){this.isEnabled=t,t||this.stop()}setScaleAndPattern(t,e){this.melodySlots.forEach(o=>{o.config.scale=t,o.config.pattern=e})}updateReverbAmount(t){console.debug(`Updating reverb amount to: ${t} for all melody slots`);for(let e=0;e<this.melodySlots.length;e++){const o=this.melodySlots[e];o.config.reverbAmount=t,o.instrument&&o.instrument.updateReverbAmount&&o.instrument.updateReverbAmount(t)}}async start(t,e){if(this.isEnabled)if(console.debug(`Starting ${this.melodySlots.length} melody slots`),this.setScaleAndPattern(t,e),this.isSingleSlotMode()){const t=this.melodySlots[0];t.instrument&&!t.isActive&&(t.instrument.synth||await t.instrument.initialize(masterVolume,reverb),this.startSlotPlayback(t))}else for(let t=0;t<this.melodySlots.length;t++){const e=this.melodySlots[t];e.instrument&&!e.isActive&&(e.instrument.synth||await e.instrument.initialize(masterVolume,reverb),setTimeout(()=>{this.startSlotPlayback(e)},2e3*t))}}startSlotPlayback(t){this.isEnabled&&!t.isActive&&(t.isActive=!0,console.debug(`Starting playback for slot ${t.id}`),t.instrument&&t.config.scale&&t.config.pattern&&(this.isSingleSlotMode()?(t.instrument.currentScale=t.config.scale,t.instrument.currentPattern=t.config.pattern,t.instrument.start(t.config.scale,t.config.pattern)):this.scheduleSlotMelody(t)))}stop(){console.debug("Stopping all melody slots"),this.melodySlots.forEach(t=>{t.isActive=!1,1===this.melodySlots.length||(t.timeout&&(clearTimeout(t.timeout),t.timeout=null),t.randomCycleTimeout&&(clearTimeout(t.randomCycleTimeout),t.randomCycleTimeout=null)),t.instrument&&t.instrument.stop()}),this.globalRandomInterval&&(clearInterval(this.globalRandomInterval),this.globalRandomInterval=null)}isSingleSlotMode(){return 1===this.melodySlots.length}scheduleSlotMelody(t){if(!t.isActive||!this.isEnabled)return;const e=()=>{if(!t.isActive||!this.isEnabled)return;t.timeout&&(clearTimeout(t.timeout),t.timeout=null);const o=this.generateMelodyForSlot(t);o.length>0&&this.playSlotMelody(t,o);const n=this.getSlotInterval(t),s=n*t.config.randomness.timing,l=n+(Math.random()-.5)*s;t.isActive&&(t.timeout=setTimeout(e,l))},o=3e3*Math.random()+2e3;t.timeout=setTimeout(e,o)}generateMelodyForSlot(t){const e=t.config.scale,o=t.config.pattern,n=t.config.randomness;if(!e||!o)return[];const s=3+t.id,l=Math.floor(3*Math.random())+s,i=[];let a;a=Math.random()<n.noteChoice?e[Math.floor(Math.random()*e.length)]:o[Math.floor(Math.random()*o.length)];let r=e.indexOf(a);-1===r&&(r=0);let m=r;i.push(e[m]);for(let t=1;t<l;t++){let t;if(Math.random()<n.noteChoice)t=Math.floor(Math.random()*e.length);else{const o=Math.floor(3*Math.random())-1;t=Math.min(Math.max(0,m+o),e.length-1)}let o=e[t];if(n.octaveShift>0&&Math.random()<n.octaveShift){const t=o.slice(0,-1),e=parseInt(o.slice(-1));o=t+(Math.random()<.5?Math.max(2,e-1):Math.min(6,e+1))}i.push(o),m=t}return i}playSlotMelody(t,e){const o=1+.3*t.id,n=.6+.2*t.id;e.forEach((e,s)=>{let l=s*n*1e3;l+=(Math.random()-.5)*t.config.randomness.timing*1e3,l=Math.max(0,l),setTimeout(()=>{if(t.isActive&&this.isEnabled){if("undefined"!=typeof activeNotes){const o=`${e}_slot${t.id}`;activeNotes[o]?activeNotes[o].count++:activeNotes[o]={count:1,type:"melodic",slot:t.id}}try{t.instrument&&t.instrument.synth&&t.instrument.synth.triggerAttackRelease(e,o)}catch(t){console.debug("Slot melody playback error:",t.message)}setTimeout(()=>{if("undefined"!=typeof activeNotes){const o=`${e}_slot${t.id}`;activeNotes[o]&&(activeNotes[o].count--,activeNotes[o].count<=0&&delete activeNotes[o])}},1e3*o+500)}},l)})}getSlotInterval(t){return 1e3*(12-(t.config.frequency||4)+2*t.id)}startRandomCycle(){this.globalRandomInterval&&clearInterval(this.globalRandomInterval);const t=document.getElementById("random-interval"),e=void 0!==t?parseInt(t.value):10,o=60*e*1e3;console.debug(`ðŸŽµ Starting melody random cycle: ${e} minutes`);const n=document.getElementById("melodic-instrument");this.globalRandomInterval=setInterval(()=>{"undefined"!=typeof isPlaying&&isPlaying&&void 0!==n&&"random"===n.value?this.changeRandomSlotInstruments():(clearInterval(this.globalRandomInterval),this.globalRandomInterval=null,console.debug("ðŸŽµ Stopped melody random cycle - conditions not met"))},o)}async changeRandomSlotInstruments(){console.debug("Changing random slot instruments");const t=Math.min(Math.floor(2*Math.random())+1,this.melodySlots.length),e=[];for(;e.length<t;){const t=Math.floor(Math.random()*this.melodySlots.length);e.includes(t)||e.push(t)}const o=this.registry.getAvailableInstruments();for(const t of e){const e=this.melodySlots[t],n=e.config.instrumentType;let s;do{s=o[Math.floor(Math.random()*o.length)]}while(s===n&&o.length>1);console.debug(`Slot ${t}: ${n} â†’ ${s}`),e.isActive=!1,e.instrument&&e.instrument.stop(),await this.setSlotInstrument(t,s),"undefined"!=typeof isPlaying&&isPlaying&&this.isEnabled&&setTimeout(()=>{this.startSlotPlayback(e)},1e3)}}updateSlotConfig(t,e){if(t>=this.melodySlots.length)return;const o=this.melodySlots[t];o.config={...o.config,...e},o.instrument&&(void 0!==e.reverbAmount&&o.instrument.updateReverbAmount(e.reverbAmount),void 0!==e.volume&&o.instrument.setVolume(e.volume))}updateAllSlotsConfig(t){for(let e=0;e<this.melodySlots.length;e++)this.updateSlotConfig(e,t)}async setInstrument(t,e={}){return console.debug(`Setting instrument (compatibility mode): ${t}`),await this.setAllSlotsToInstrument(t,e),this.melodySlots[0]?.instrument||null}disposeAllSlots(){this.melodySlots.forEach(t=>{t.timeout&&clearTimeout(t.timeout),t.randomCycleTimeout&&clearTimeout(t.randomCycleTimeout),t.instrument&&t.instrument.dispose()})}dispose(){this.stop(),this.disposeAllSlots(),this.melodySlots=[]}getCurrentSlotCount(){return this.currentSlotCount}getMaxSlots(){return this.maxSlots}}console.log("âœ… Multi-Melody System loaded");